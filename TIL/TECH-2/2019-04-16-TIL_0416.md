---
title: "TIL - 0416"
date: 2019-04-16 00:00:00
img:
categories:
- TIL, Deep_into_algorithm
---

## 삽입 정렬과 합병 정렬

1. 정렬
- 예) 전화번호 , 중간값 찾기

```
array A[0:n] -> B[0:n]
unsorted
```
- 중간값은 배열을 하면서 얻어지는 결과값 중 하나인 것
- 짝수인 경우 B[n/2] 값을 가지면 됨
- 정렬된 리스트가 있으면 상수의 시간이 걸림 O(n)
- 이진탐색 -> 특정 숫자를 찾아봄 -> 배열전체를 보기 때문에 "선형 시간"걸림 -> k를 B[n/2]와 비교함 (B는 정렬이 되어있음)
- 정렬된 리스트가 있으면 쉬워지는 문제들과 아닌 경우가 있는데 데이터압축이 그 예시임
    - 데이터 압축: 정렬로 중복된 부분 검출
    - 컴퓨터 그래픽: 앞에서 뒤로 화면 렌더링

2. 삽입 정렬
- 의사코드
```code
for i = 1,2 ... N
  insert A[i] into sorted array A[0:i-1] #i-1까지 정렬이 되어잇음
  쌍별 스왑 작업 by parallelwise swaps down to correct position
```

- 예
```
key = 2        key = 4        key = 6 -> key = 1
5,2,4,6,1,3 -> 2,5,4,6,1,3 -> 2,4,5,6,1,3 -> 2,4,5,1,6,3 (swap 4번)
    key=3
-> 1,2,4,5,6,3 (swap 3번) -> 1,2,3,4,5,6
```

- 분석
    - O(n)번 key이동
    - 전체는 O(n^2) : 각 단계가 O(n^2) , O(n^2)번 비교
    - 역순으로 정렬되어잇는 경우 각 단계를 지날때마다 평균 n/2 스왑 -> 각 단계는 O(n)단계 swap
    - swap과 비교 비용을 비슷하다고 가정
    - 비교의 비용이 큰 경우 어떻게 복잡도를 개선할 수 있을가?
        - 이진탐색 -> O(nlogn)

3. 이진탐색
```
Do a binary Search on A[0:i-1] 이미 정렬되어있음
각 단계에서 O(logn)만큼만 보면 되고 ->  비교시간 : O(nlogn)
```
- 적절한 자리에 삽입해야 함
- 비교 O(nlogn), 스왑 O(n^2)
