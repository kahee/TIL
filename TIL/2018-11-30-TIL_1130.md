---
title: "TIL - 1130"
date: 2018-11-30 00:00:00
img:
categories:
- TIL, Network
---

## 컴퓨터 네트워킹

----

## Reliable Data Transfer Principles

1. 신뢰성있는 전송을 제공하기 위한 것들

2. 에러 타입과 해결법
- bit 에러 : 1이 0으로 0이 1로 변환
- 해결법 :  checksum이 있으면 segment가 에러를 포함되어있는지 않은지를 판단 할 수 있다. / 비트 에러가 없다면 송신자가 수진자한테 ACK(Acknowledgement)를 보냄
- 패킷 로스 : 송신자 입장에서는 sender가 무엇을 보냈는지를 알 수가 없다.
- 해결 문제 : 타임아웃 / sender가 데이터를 보내고 일정 시간이 지나고 응답이 없는 경우, 데이터를 재전송한다.
- 만약 수신자가 받고 ACK를 보냈는 그 순간에 패킷이 사라진 거면 송신자는 도작하지 않은 것으로 간주하여 다시 요청 -> 수신자의 입장에선 같은 메시지가 두번 도착 : 이 경우 내용자체가 같은 것이닞 판단할 수가 없다. - 재전송 혹은 다른 segment인데 똑같은 메시지 인지 판단할수 없음 -> 그래서 sequence number 를 통해 이를 구분
- 데이터 중복을 막을 수 있다.
- 데이터를 한번에 다 보내는 것이 아니라 패킷단위로 분할에서 보내기 때문에 순서대로 보내지 않을 수도 있기 때문에 응용 에서 이러한 sequence number를 통해 순서를 맞출 수 있다.

3. communication error recovery
- ARQ (Automatic repeat request)
    - stop - and - wait : 한번에 하나의 세그먼트를 보내고 이를 검사받고 이런식
    - pipelining method : 한버에 보내고 검사하는 방식으로 퍼모먼스가 낮음
        -  go back - N
        - selective repeat

4. Stop and wait
- 패킷 하나 보내고 응답하나 받고 이런 식으로
- 일정시간이 지나도록 ACK를 못받으면 재전송
- 패킷 분실과 / ack 분실 -> sender 입장에서는 같은 오류임 결과적으로 응답을 제대로 받지 못했기 때문 -> 타이머가 종료되면 다시 재전송
- reciever 입장에서는 다름 sequece number 를 통해 재전송이라는 것을 판단하여 재전송
- 타입아웃 시간을 어떻게 잡는가? 너무 긴시간을 기달려야 하는 경우 전송속도가 낮아지는 문제가 있음 / 너무 짧으면 네트워크 혼잡을 통해 ack 가 좀 느리게 도착하는 바람에 다시 재전송을 요청하게 되고 다시 보내는 문제가 발생한다.
- 물리자원을 낭비하는 문제가 발생한다.

5. pipelining
- 한번에 여러개를 보내고 병렬적으로 ACK가 오면 좀더 효율이 높지 않는가?
- 효율성을 높일 수 있음 -> 전송시간이 세배로 늘어난다.
- go-back-N : n 개의 데이터를 보낼 수 있음 / 만약 중간에 잘못된 패킷이 있으면 앞에서부터 다시 재전송  -> 앞선 ACK 를 보내서 그 이후에서부터 다시 재전송해달라는 표시 / 타임아웃이내에 제대로 도달하지 않으면 개별적인 타이머가 필요없이 가장 먼저 보낸 패킷에 대한 타이머가 설정되어있는데 그내에 못받으면 다시 재전송
- select repeat : n 개의 데이터를 보낼 수 잇음
/ 잘못된 패킷만 재전송 -> 개별적인  ack를 보내서 개별패킷을 보내서 다시 재전송 / 개별적인 타이머를 가지고 있다. 특정 패킷에 대해서만 재전송

6. Go back N
- 윈도우 : 한번에 보낼 수 있는 데이터 사이즈
- 수신자 입장에서 데이터가 한번에 다왔을 때 각각의 패킷에 ACK를 보내는 것이 아니라 정해진 단위마다마 ACK를 보냄
- Cumulative ACK : 이전의 모든 ack 를 받았다는 의미
- 타이머의 경우 ack를 받지 못한 패킷 중에 가장 먼저 보낸 패킷에 대해서 타이머가 설정
- 윈도우 사이즈는 시간에 따라 변화할 수 있다. 크기가 클수록 throughput 은 높아진다.
- 윈도우 사이즈가 크다고 무조건 좋은 것은 아니다. 왜냐하면 재전송을 보내야하는 경우, 사이즈 크기가 커지면 패킷의 수가 기하급수적으로 늘어난다. -> 효율성이 낮아짐
- 윈도우 사이즈는 네트워크의 혼잡이나 reciever 버퍼가 수용할 수 잇는 크기를 넘지 않는 한에서 조절해야 한다.

7. GBN operation
- 순서에 맞지 않는 ack 패킷은 버린다.

8. Selective Repeat
- 각각의 패킷에 대해 개별적인 ack를 사용
- 각각의 ack를 팟지 못한 패킷에 대해 타이머가 개별적으로 설지 되어있음
- 2번이 도달하지 않는 상황에서 3,4,5는 버리지 않고 버터에 올려놓았다가 2번이 도착하면 같이 묶어서 응용 프로그램에 보내준다.

9. seq. number 와 윈도우 사이즈
- 헤더에 들어가는 것이 sequence number 인데 크기가 얼마나 되어야 하는가?
- ACK가 분실되어 재전송을 요청하는 경우, 문제가 있을 수 있다. -> 윈도우 사이즈에 비해 seq 넘버가 너무 작기 때문이다. 그래서 윈도우 사이즈는 seq 넘버 사이즈의 절반 이하여야 함.

----

[Keyword]


- 단편화(fragmentation): 링크가 허용하는 최대 데이터 크기 이하로 패킷을 작은 조각으로 나누는 과정 (참조: https://en.wikipedia.org/wiki/IP_fragmentation)

- 다중화(multiplexing): 다수의 응용에서 동시에 발생된 독립적인 세그먼트들을 하나의 전송로를 통해 전달하는 과정 (http://www.tcpipguide.com/free/t_TCPIPProcessesMultiplexingandClientServerApplicati-2.htm)

- 역다중화(demultiplexing): 수신된 다양한 세그먼트들을 전송 계층에서 분리하여 해당 응용으로 전달하는 과정

- 간이 망 관리 프로토콜(Simple Network Management Protocol, SNMP): 네트워크상에 존재하는 장치들의 정보 수집, 관리, 제어를 위해 사용되는 인터넷 표준 프로토콜

- 체크섬(checksum): 수신된 데이터의 정확성을 검사하기 위해 사용되는 전송 데이터의 합계

- ACK(acknowledge): 송신측이 전송한 데이터가 올바르게 도착했음을 알리는 수신측의 응답

- 파이프라이닝(pipelining): 하나의 처리과정이 끝나고 다음 처리과정이 수행되는 것이 아닌, 여러 단계를 병렬적으로 수행하여 처리속도를 높이는 기술
